{"ast":null,"code":"var _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react';\nimport webSocketService from '../services/WebSocketService';\nfunction AudioRecorder({\n  isRecording,\n  onStatusChange,\n  audioContext\n}) {\n  _s();\n  const mediaRecorderRef = useRef(null);\n  const audioChunksRef = useRef([]);\n  const streamRef = useRef(null);\n  useEffect(() => {\n    // Start or stop recording based on isRecording prop\n    if (isRecording) {\n      startRecording();\n    } else {\n      stopRecording();\n    }\n\n    // Cleanup function to ensure we stop recording and release media resources\n    return () => {\n      if (mediaRecorderRef.current && mediaRecorderRef.current.state !== 'inactive') {\n        mediaRecorderRef.current.stop();\n      }\n      if (streamRef.current) {\n        streamRef.current.getTracks().forEach(track => track.stop());\n      }\n    };\n  }, [isRecording]);\n  const startRecording = async () => {\n    audioChunksRef.current = [];\n    try {\n      // Get microphone access\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          echoCancellation: true,\n          noiseSuppression: true,\n          autoGainControl: true\n        }\n      });\n      streamRef.current = stream;\n\n      // Create MediaRecorder instance\n      const mediaRecorder = new MediaRecorder(stream);\n      mediaRecorderRef.current = mediaRecorder;\n\n      // Set up event handlers\n      mediaRecorder.ondataavailable = handleDataAvailable;\n      mediaRecorder.onstop = handleRecordingStop;\n\n      // Resume AudioContext if it's suspended (needed for Safari)\n      if (audioContext && audioContext.state === 'suspended') {\n        await audioContext.resume();\n      }\n\n      // Start recording\n      mediaRecorder.start(100); // Collect data every 100ms for real-time streaming\n      console.log('Recording started');\n\n      // Notify parent of successful start\n      if (onStatusChange) {\n        onStatusChange(true);\n      }\n    } catch (err) {\n      console.error('Error starting recording:', err);\n      if (onStatusChange) {\n        onStatusChange(false);\n      }\n    }\n  };\n  const stopRecording = () => {\n    if (mediaRecorderRef.current && mediaRecorderRef.current.state !== 'inactive') {\n      mediaRecorderRef.current.stop();\n      console.log('Recording stopped');\n    }\n    if (streamRef.current) {\n      streamRef.current.getTracks().forEach(track => track.stop());\n      streamRef.current = null;\n    }\n  };\n  const handleDataAvailable = event => {\n    if (event.data && event.data.size > 0) {\n      audioChunksRef.current.push(event.data);\n\n      // For real-time streaming, you might want to send each chunk as it becomes available\n      sendAudioChunk(event.data);\n    }\n  };\n  const handleRecordingStop = () => {\n    // Convert all recorded chunks to a single blob\n    const audioBlob = new Blob(audioChunksRef.current, {\n      type: 'audio/webm'\n    });\n\n    // You might want to send the complete recording here as well\n    // or just rely on the chunks that were sent in real-time\n\n    // Reset state\n    audioChunksRef.current = [];\n\n    // Notify parent\n    if (onStatusChange) {\n      onStatusChange(false);\n    }\n  };\n  const sendAudioChunk = async chunk => {\n    // Convert the blob to base64 for sending over WebSocket\n    const reader = new FileReader();\n    reader.readAsDataURL(chunk);\n    reader.onloadend = () => {\n      // Extract the base64 data (remove the data URL prefix)\n      const base64data = reader.result.split(',')[1];\n\n      // Send to server\n      webSocketService.sendAudio(base64data);\n    };\n  };\n\n  // Invisible component - no UI\n  return null;\n}\n_s(AudioRecorder, \"WoCVHELKLbFQqrSvLuN5f9bpQaU=\");\n_c = AudioRecorder;\nexport default AudioRecorder;\nvar _c;\n$RefreshReg$(_c, \"AudioRecorder\");","map":{"version":3,"names":["React","useState","useEffect","useRef","webSocketService","AudioRecorder","isRecording","onStatusChange","audioContext","_s","mediaRecorderRef","audioChunksRef","streamRef","startRecording","stopRecording","current","state","stop","getTracks","forEach","track","stream","navigator","mediaDevices","getUserMedia","audio","echoCancellation","noiseSuppression","autoGainControl","mediaRecorder","MediaRecorder","ondataavailable","handleDataAvailable","onstop","handleRecordingStop","resume","start","console","log","err","error","event","data","size","push","sendAudioChunk","audioBlob","Blob","type","chunk","reader","FileReader","readAsDataURL","onloadend","base64data","result","split","sendAudio","_c","$RefreshReg$"],"sources":["/Users/matheusrech/Documents/gemini-voice-reading-assistant/frontend/src/components/AudioRecorder.js"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\nimport webSocketService from '../services/WebSocketService';\n\nfunction AudioRecorder({ isRecording, onStatusChange, audioContext }) {\n  const mediaRecorderRef = useRef(null);\n  const audioChunksRef = useRef([]);\n  const streamRef = useRef(null);\n  \n  useEffect(() => {\n    // Start or stop recording based on isRecording prop\n    if (isRecording) {\n      startRecording();\n    } else {\n      stopRecording();\n    }\n    \n    // Cleanup function to ensure we stop recording and release media resources\n    return () => {\n      if (mediaRecorderRef.current && mediaRecorderRef.current.state !== 'inactive') {\n        mediaRecorderRef.current.stop();\n      }\n      if (streamRef.current) {\n        streamRef.current.getTracks().forEach(track => track.stop());\n      }\n    };\n  }, [isRecording]);\n\n  const startRecording = async () => {\n    audioChunksRef.current = [];\n    \n    try {\n      // Get microphone access\n      const stream = await navigator.mediaDevices.getUserMedia({ \n        audio: {\n          echoCancellation: true,\n          noiseSuppression: true,\n          autoGainControl: true\n        } \n      });\n      streamRef.current = stream;\n      \n      // Create MediaRecorder instance\n      const mediaRecorder = new MediaRecorder(stream);\n      mediaRecorderRef.current = mediaRecorder;\n      \n      // Set up event handlers\n      mediaRecorder.ondataavailable = handleDataAvailable;\n      mediaRecorder.onstop = handleRecordingStop;\n      \n      // Resume AudioContext if it's suspended (needed for Safari)\n      if (audioContext && audioContext.state === 'suspended') {\n        await audioContext.resume();\n      }\n      \n      // Start recording\n      mediaRecorder.start(100); // Collect data every 100ms for real-time streaming\n      console.log('Recording started');\n      \n      // Notify parent of successful start\n      if (onStatusChange) {\n        onStatusChange(true);\n      }\n    } catch (err) {\n      console.error('Error starting recording:', err);\n      if (onStatusChange) {\n        onStatusChange(false);\n      }\n    }\n  };\n\n  const stopRecording = () => {\n    if (mediaRecorderRef.current && mediaRecorderRef.current.state !== 'inactive') {\n      mediaRecorderRef.current.stop();\n      console.log('Recording stopped');\n    }\n    \n    if (streamRef.current) {\n      streamRef.current.getTracks().forEach(track => track.stop());\n      streamRef.current = null;\n    }\n  };\n\n  const handleDataAvailable = (event) => {\n    if (event.data && event.data.size > 0) {\n      audioChunksRef.current.push(event.data);\n      \n      // For real-time streaming, you might want to send each chunk as it becomes available\n      sendAudioChunk(event.data);\n    }\n  };\n\n  const handleRecordingStop = () => {\n    // Convert all recorded chunks to a single blob\n    const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/webm' });\n    \n    // You might want to send the complete recording here as well\n    // or just rely on the chunks that were sent in real-time\n    \n    // Reset state\n    audioChunksRef.current = [];\n    \n    // Notify parent\n    if (onStatusChange) {\n      onStatusChange(false);\n    }\n  };\n\n  const sendAudioChunk = async (chunk) => {\n    // Convert the blob to base64 for sending over WebSocket\n    const reader = new FileReader();\n    reader.readAsDataURL(chunk);\n    \n    reader.onloadend = () => {\n      // Extract the base64 data (remove the data URL prefix)\n      const base64data = reader.result.split(',')[1];\n      \n      // Send to server\n      webSocketService.sendAudio(base64data);\n    };\n  };\n\n  // Invisible component - no UI\n  return null;\n}\n\nexport default AudioRecorder;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}