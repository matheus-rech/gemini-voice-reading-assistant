{"ast":null,"code":"var _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react';\nimport webSocketService from '../services/WebSocketService';\nfunction AudioRecorder({\n  isRecording,\n  onStatusChange\n}) {\n  _s();\n  const mediaRecorderRef = useRef(null);\n  const audioChunksRef = useRef([]);\n  const streamRef = useRef(null);\n  useEffect(() => {\n    // Start or stop recording based on isRecording prop\n    if (isRecording) {\n      startRecording();\n    } else {\n      stopRecording();\n    }\n\n    // Cleanup function to ensure we stop recording and release media resources\n    return () => {\n      if (mediaRecorderRef.current && mediaRecorderRef.current.state !== 'inactive') {\n        mediaRecorderRef.current.stop();\n      }\n      if (streamRef.current) {\n        streamRef.current.getTracks().forEach(track => track.stop());\n      }\n    };\n  }, [isRecording]);\n  const startRecording = async () => {\n    audioChunksRef.current = [];\n    try {\n      // Get microphone access\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      streamRef.current = stream;\n\n      // Create MediaRecorder instance\n      const mediaRecorder = new MediaRecorder(stream);\n      mediaRecorderRef.current = mediaRecorder;\n\n      // Set up event handlers\n      mediaRecorder.ondataavailable = handleDataAvailable;\n      mediaRecorder.onstop = handleRecordingStop;\n\n      // Start recording\n      mediaRecorder.start(100); // Collect data every 100ms for real-time streaming\n      console.log('Recording started');\n\n      // Notify parent of successful start\n      if (onStatusChange) {\n        onStatusChange(true);\n      }\n    } catch (err) {\n      console.error('Error starting recording:', err);\n      if (onStatusChange) {\n        onStatusChange(false);\n      }\n    }\n  };\n  const stopRecording = () => {\n    if (mediaRecorderRef.current && mediaRecorderRef.current.state !== 'inactive') {\n      mediaRecorderRef.current.stop();\n      console.log('Recording stopped');\n    }\n    if (streamRef.current) {\n      streamRef.current.getTracks().forEach(track => track.stop());\n      streamRef.current = null;\n    }\n  };\n  const handleDataAvailable = event => {\n    if (event.data && event.data.size > 0) {\n      audioChunksRef.current.push(event.data);\n\n      // For real-time streaming, you might want to send each chunk as it becomes available\n      sendAudioChunk(event.data);\n    }\n  };\n  const handleRecordingStop = () => {\n    // Convert all recorded chunks to a single blob\n    const audioBlob = new Blob(audioChunksRef.current, {\n      type: 'audio/webm'\n    });\n\n    // You might want to send the complete recording here as well\n    // or just rely on the chunks that were sent in real-time\n\n    // Reset state\n    audioChunksRef.current = [];\n\n    // Notify parent\n    if (onStatusChange) {\n      onStatusChange(false);\n    }\n  };\n  const sendAudioChunk = async chunk => {\n    // Convert the blob to base64 for sending over WebSocket\n    const reader = new FileReader();\n    reader.readAsDataURL(chunk);\n    reader.onloadend = () => {\n      // Extract the base64 data (remove the data URL prefix)\n      const base64data = reader.result.split(',')[1];\n\n      // Send to server\n      webSocketService.sendAudio(base64data);\n    };\n  };\n\n  // Invisible component - no UI\n  return null;\n}\n_s(AudioRecorder, \"WoCVHELKLbFQqrSvLuN5f9bpQaU=\");\n_c = AudioRecorder;\nexport default AudioRecorder;\nvar _c;\n$RefreshReg$(_c, \"AudioRecorder\");","map":{"version":3,"names":["React","useState","useEffect","useRef","webSocketService","AudioRecorder","isRecording","onStatusChange","_s","mediaRecorderRef","audioChunksRef","streamRef","startRecording","stopRecording","current","state","stop","getTracks","forEach","track","stream","navigator","mediaDevices","getUserMedia","audio","mediaRecorder","MediaRecorder","ondataavailable","handleDataAvailable","onstop","handleRecordingStop","start","console","log","err","error","event","data","size","push","sendAudioChunk","audioBlob","Blob","type","chunk","reader","FileReader","readAsDataURL","onloadend","base64data","result","split","sendAudio","_c","$RefreshReg$"],"sources":["/Users/matheusrech/Documents/gemini-voice-reading-assistant/frontend/src/components/AudioRecorder.js"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\nimport webSocketService from '../services/WebSocketService';\n\nfunction AudioRecorder({ isRecording, onStatusChange }) {\n  const mediaRecorderRef = useRef(null);\n  const audioChunksRef = useRef([]);\n  const streamRef = useRef(null);\n  \n  useEffect(() => {\n    // Start or stop recording based on isRecording prop\n    if (isRecording) {\n      startRecording();\n    } else {\n      stopRecording();\n    }\n    \n    // Cleanup function to ensure we stop recording and release media resources\n    return () => {\n      if (mediaRecorderRef.current && mediaRecorderRef.current.state !== 'inactive') {\n        mediaRecorderRef.current.stop();\n      }\n      if (streamRef.current) {\n        streamRef.current.getTracks().forEach(track => track.stop());\n      }\n    };\n  }, [isRecording]);\n\n  const startRecording = async () => {\n    audioChunksRef.current = [];\n    \n    try {\n      // Get microphone access\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n      streamRef.current = stream;\n      \n      // Create MediaRecorder instance\n      const mediaRecorder = new MediaRecorder(stream);\n      mediaRecorderRef.current = mediaRecorder;\n      \n      // Set up event handlers\n      mediaRecorder.ondataavailable = handleDataAvailable;\n      mediaRecorder.onstop = handleRecordingStop;\n      \n      // Start recording\n      mediaRecorder.start(100); // Collect data every 100ms for real-time streaming\n      console.log('Recording started');\n      \n      // Notify parent of successful start\n      if (onStatusChange) {\n        onStatusChange(true);\n      }\n    } catch (err) {\n      console.error('Error starting recording:', err);\n      if (onStatusChange) {\n        onStatusChange(false);\n      }\n    }\n  };\n\n  const stopRecording = () => {\n    if (mediaRecorderRef.current && mediaRecorderRef.current.state !== 'inactive') {\n      mediaRecorderRef.current.stop();\n      console.log('Recording stopped');\n    }\n    \n    if (streamRef.current) {\n      streamRef.current.getTracks().forEach(track => track.stop());\n      streamRef.current = null;\n    }\n  };\n\n  const handleDataAvailable = (event) => {\n    if (event.data && event.data.size > 0) {\n      audioChunksRef.current.push(event.data);\n      \n      // For real-time streaming, you might want to send each chunk as it becomes available\n      sendAudioChunk(event.data);\n    }\n  };\n\n  const handleRecordingStop = () => {\n    // Convert all recorded chunks to a single blob\n    const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/webm' });\n    \n    // You might want to send the complete recording here as well\n    // or just rely on the chunks that were sent in real-time\n    \n    // Reset state\n    audioChunksRef.current = [];\n    \n    // Notify parent\n    if (onStatusChange) {\n      onStatusChange(false);\n    }\n  };\n\n  const sendAudioChunk = async (chunk) => {\n    // Convert the blob to base64 for sending over WebSocket\n    const reader = new FileReader();\n    reader.readAsDataURL(chunk);\n    \n    reader.onloadend = () => {\n      // Extract the base64 data (remove the data URL prefix)\n      const base64data = reader.result.split(',')[1];\n      \n      // Send to server\n      webSocketService.sendAudio(base64data);\n    };\n  };\n\n  // Invisible component - no UI\n  return null;\n}\n\nexport default AudioRecorder;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}