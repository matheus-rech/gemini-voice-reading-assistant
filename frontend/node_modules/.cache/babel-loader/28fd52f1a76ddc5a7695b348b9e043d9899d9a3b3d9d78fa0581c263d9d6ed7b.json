{"ast":null,"code":"class WebSocketService {\n  constructor() {\n    this.socket = null;\n    this.isConnected = false;\n    this.messageHandler = null;\n    this.statusChangeHandler = null;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectTimeout = null;\n  }\n  connect() {\n    // Check if already connected\n    if (this.socket && this.isConnected) {\n      console.log('WebSocket already connected');\n      return;\n    }\n\n    // Close existing socket if any\n    if (this.socket) {\n      this.socket.close();\n    }\n\n    // Create new WebSocket connection\n    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n    const host = process.env.REACT_APP_WS_HOST || window.location.hostname;\n    const port = process.env.REACT_APP_WS_PORT || '8000';\n    const wsUrl = `${protocol}//${host}:${port}`;\n    console.log(`Connecting to WebSocket: ${wsUrl}`);\n    try {\n      this.socket = new WebSocket(wsUrl);\n\n      // Set up event handlers\n      this.socket.onopen = this.handleOpen.bind(this);\n      this.socket.onclose = this.handleClose.bind(this);\n      this.socket.onerror = this.handleError.bind(this);\n      this.socket.onmessage = this.handleMessage.bind(this);\n    } catch (error) {\n      console.error('Error creating WebSocket:', error);\n      this.scheduleReconnect();\n    }\n  }\n  handleOpen() {\n    console.log('WebSocket connected');\n    this.isConnected = true;\n    this.reconnectAttempts = 0;\n    if (this.statusChangeHandler) {\n      this.statusChangeHandler(true);\n    }\n  }\n  handleClose(event) {\n    console.log(`WebSocket closed: ${event.code} - ${event.reason}`);\n    this.isConnected = false;\n    if (this.statusChangeHandler) {\n      this.statusChangeHandler(false);\n    }\n\n    // Attempt to reconnect if not explicitly closed by the client\n    if (event.code !== 1000) {\n      this.scheduleReconnect();\n    }\n  }\n  handleError(error) {\n    console.error('WebSocket error:', error);\n    // The WebSocket will attempt to reconnect automatically on error\n  }\n  handleMessage(event) {\n    try {\n      const data = JSON.parse(event.data);\n      if (this.messageHandler) {\n        this.messageHandler(data);\n      }\n    } catch (error) {\n      console.error('Error parsing WebSocket message:', error);\n    }\n  }\n  scheduleReconnect() {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts - 1), 30000);\n      console.log(`Scheduling reconnect attempt ${this.reconnectAttempts} in ${delay}ms`);\n\n      // Clear any existing timeout\n      if (this.reconnectTimeout) {\n        clearTimeout(this.reconnectTimeout);\n      }\n      this.reconnectTimeout = setTimeout(() => {\n        console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n        this.connect();\n      }, delay);\n    } else {\n      console.error('Maximum reconnect attempts reached');\n    }\n  }\n  sendMessage(type, content) {\n    if (!this.socket || !this.isConnected) {\n      console.error('Cannot send message, WebSocket not connected');\n      return false;\n    }\n    try {\n      const message = JSON.stringify({\n        type,\n        content\n      });\n      this.socket.send(message);\n      return true;\n    } catch (error) {\n      console.error('Error sending WebSocket message:', error);\n      return false;\n    }\n  }\n  sendText(text) {\n    return this.sendMessage('text', text);\n  }\n  sendAudio(audioData) {\n    return this.sendMessage('audio', audioData);\n  }\n  sendMode(mode) {\n    return this.sendMessage('mode', mode);\n  }\n  setMessageHandler(handler) {\n    this.messageHandler = handler;\n  }\n  setStatusChangeHandler(handler) {\n    this.statusChangeHandler = handler;\n  }\n  disconnect() {\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    if (this.socket) {\n      this.socket.close(1000, 'Client disconnected');\n      this.socket = null;\n    }\n    this.isConnected = false;\n  }\n}\n\n// Create singleton instance\nconst webSocketService = new WebSocketService();\nexport default webSocketService;","map":{"version":3,"names":["WebSocketService","constructor","socket","isConnected","messageHandler","statusChangeHandler","reconnectAttempts","maxReconnectAttempts","reconnectTimeout","connect","console","log","close","protocol","window","location","host","process","env","REACT_APP_WS_HOST","hostname","port","REACT_APP_WS_PORT","wsUrl","WebSocket","onopen","handleOpen","bind","onclose","handleClose","onerror","handleError","onmessage","handleMessage","error","scheduleReconnect","event","code","reason","data","JSON","parse","delay","Math","min","pow","clearTimeout","setTimeout","sendMessage","type","content","message","stringify","send","sendText","text","sendAudio","audioData","sendMode","mode","setMessageHandler","handler","setStatusChangeHandler","disconnect","webSocketService"],"sources":["/Users/matheusrech/Documents/gemini-voice-reading-assistant/frontend/src/services/WebSocketService.js"],"sourcesContent":["class WebSocketService {\n  constructor() {\n    this.socket = null;\n    this.isConnected = false;\n    this.messageHandler = null;\n    this.statusChangeHandler = null;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectTimeout = null;\n  }\n\n  connect() {\n    // Check if already connected\n    if (this.socket && this.isConnected) {\n      console.log('WebSocket already connected');\n      return;\n    }\n\n    // Close existing socket if any\n    if (this.socket) {\n      this.socket.close();\n    }\n\n    // Create new WebSocket connection\n    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n    const host = process.env.REACT_APP_WS_HOST || window.location.hostname;\n    const port = process.env.REACT_APP_WS_PORT || '8000';\n    const wsUrl = `${protocol}//${host}:${port}`;\n\n    console.log(`Connecting to WebSocket: ${wsUrl}`);\n    \n    try {\n      this.socket = new WebSocket(wsUrl);\n\n      // Set up event handlers\n      this.socket.onopen = this.handleOpen.bind(this);\n      this.socket.onclose = this.handleClose.bind(this);\n      this.socket.onerror = this.handleError.bind(this);\n      this.socket.onmessage = this.handleMessage.bind(this);\n    } catch (error) {\n      console.error('Error creating WebSocket:', error);\n      this.scheduleReconnect();\n    }\n  }\n\n  handleOpen() {\n    console.log('WebSocket connected');\n    this.isConnected = true;\n    this.reconnectAttempts = 0;\n    if (this.statusChangeHandler) {\n      this.statusChangeHandler(true);\n    }\n  }\n\n  handleClose(event) {\n    console.log(`WebSocket closed: ${event.code} - ${event.reason}`);\n    this.isConnected = false;\n    \n    if (this.statusChangeHandler) {\n      this.statusChangeHandler(false);\n    }\n    \n    // Attempt to reconnect if not explicitly closed by the client\n    if (event.code !== 1000) {\n      this.scheduleReconnect();\n    }\n  }\n\n  handleError(error) {\n    console.error('WebSocket error:', error);\n    // The WebSocket will attempt to reconnect automatically on error\n  }\n\n  handleMessage(event) {\n    try {\n      const data = JSON.parse(event.data);\n      if (this.messageHandler) {\n        this.messageHandler(data);\n      }\n    } catch (error) {\n      console.error('Error parsing WebSocket message:', error);\n    }\n  }\n\n  scheduleReconnect() {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts - 1), 30000);\n      \n      console.log(`Scheduling reconnect attempt ${this.reconnectAttempts} in ${delay}ms`);\n      \n      // Clear any existing timeout\n      if (this.reconnectTimeout) {\n        clearTimeout(this.reconnectTimeout);\n      }\n      \n      this.reconnectTimeout = setTimeout(() => {\n        console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n        this.connect();\n      }, delay);\n    } else {\n      console.error('Maximum reconnect attempts reached');\n    }\n  }\n\n  sendMessage(type, content) {\n    if (!this.socket || !this.isConnected) {\n      console.error('Cannot send message, WebSocket not connected');\n      return false;\n    }\n\n    try {\n      const message = JSON.stringify({ type, content });\n      this.socket.send(message);\n      return true;\n    } catch (error) {\n      console.error('Error sending WebSocket message:', error);\n      return false;\n    }\n  }\n\n  sendText(text) {\n    return this.sendMessage('text', text);\n  }\n\n  sendAudio(audioData) {\n    return this.sendMessage('audio', audioData);\n  }\n\n  sendMode(mode) {\n    return this.sendMessage('mode', mode);\n  }\n\n  setMessageHandler(handler) {\n    this.messageHandler = handler;\n  }\n\n  setStatusChangeHandler(handler) {\n    this.statusChangeHandler = handler;\n  }\n\n  disconnect() {\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n\n    if (this.socket) {\n      this.socket.close(1000, 'Client disconnected');\n      this.socket = null;\n    }\n    \n    this.isConnected = false;\n  }\n}\n\n// Create singleton instance\nconst webSocketService = new WebSocketService();\nexport default webSocketService;"],"mappings":"AAAA,MAAMA,gBAAgB,CAAC;EACrBC,WAAWA,CAAA,EAAG;IACZ,IAAI,CAACC,MAAM,GAAG,IAAI;IAClB,IAAI,CAACC,WAAW,GAAG,KAAK;IACxB,IAAI,CAACC,cAAc,GAAG,IAAI;IAC1B,IAAI,CAACC,mBAAmB,GAAG,IAAI;IAC/B,IAAI,CAACC,iBAAiB,GAAG,CAAC;IAC1B,IAAI,CAACC,oBAAoB,GAAG,CAAC;IAC7B,IAAI,CAACC,gBAAgB,GAAG,IAAI;EAC9B;EAEAC,OAAOA,CAAA,EAAG;IACR;IACA,IAAI,IAAI,CAACP,MAAM,IAAI,IAAI,CAACC,WAAW,EAAE;MACnCO,OAAO,CAACC,GAAG,CAAC,6BAA6B,CAAC;MAC1C;IACF;;IAEA;IACA,IAAI,IAAI,CAACT,MAAM,EAAE;MACf,IAAI,CAACA,MAAM,CAACU,KAAK,CAAC,CAAC;IACrB;;IAEA;IACA,MAAMC,QAAQ,GAAGC,MAAM,CAACC,QAAQ,CAACF,QAAQ,KAAK,QAAQ,GAAG,MAAM,GAAG,KAAK;IACvE,MAAMG,IAAI,GAAGC,OAAO,CAACC,GAAG,CAACC,iBAAiB,IAAIL,MAAM,CAACC,QAAQ,CAACK,QAAQ;IACtE,MAAMC,IAAI,GAAGJ,OAAO,CAACC,GAAG,CAACI,iBAAiB,IAAI,MAAM;IACpD,MAAMC,KAAK,GAAG,GAAGV,QAAQ,KAAKG,IAAI,IAAIK,IAAI,EAAE;IAE5CX,OAAO,CAACC,GAAG,CAAC,4BAA4BY,KAAK,EAAE,CAAC;IAEhD,IAAI;MACF,IAAI,CAACrB,MAAM,GAAG,IAAIsB,SAAS,CAACD,KAAK,CAAC;;MAElC;MACA,IAAI,CAACrB,MAAM,CAACuB,MAAM,GAAG,IAAI,CAACC,UAAU,CAACC,IAAI,CAAC,IAAI,CAAC;MAC/C,IAAI,CAACzB,MAAM,CAAC0B,OAAO,GAAG,IAAI,CAACC,WAAW,CAACF,IAAI,CAAC,IAAI,CAAC;MACjD,IAAI,CAACzB,MAAM,CAAC4B,OAAO,GAAG,IAAI,CAACC,WAAW,CAACJ,IAAI,CAAC,IAAI,CAAC;MACjD,IAAI,CAACzB,MAAM,CAAC8B,SAAS,GAAG,IAAI,CAACC,aAAa,CAACN,IAAI,CAAC,IAAI,CAAC;IACvD,CAAC,CAAC,OAAOO,KAAK,EAAE;MACdxB,OAAO,CAACwB,KAAK,CAAC,2BAA2B,EAAEA,KAAK,CAAC;MACjD,IAAI,CAACC,iBAAiB,CAAC,CAAC;IAC1B;EACF;EAEAT,UAAUA,CAAA,EAAG;IACXhB,OAAO,CAACC,GAAG,CAAC,qBAAqB,CAAC;IAClC,IAAI,CAACR,WAAW,GAAG,IAAI;IACvB,IAAI,CAACG,iBAAiB,GAAG,CAAC;IAC1B,IAAI,IAAI,CAACD,mBAAmB,EAAE;MAC5B,IAAI,CAACA,mBAAmB,CAAC,IAAI,CAAC;IAChC;EACF;EAEAwB,WAAWA,CAACO,KAAK,EAAE;IACjB1B,OAAO,CAACC,GAAG,CAAC,qBAAqByB,KAAK,CAACC,IAAI,MAAMD,KAAK,CAACE,MAAM,EAAE,CAAC;IAChE,IAAI,CAACnC,WAAW,GAAG,KAAK;IAExB,IAAI,IAAI,CAACE,mBAAmB,EAAE;MAC5B,IAAI,CAACA,mBAAmB,CAAC,KAAK,CAAC;IACjC;;IAEA;IACA,IAAI+B,KAAK,CAACC,IAAI,KAAK,IAAI,EAAE;MACvB,IAAI,CAACF,iBAAiB,CAAC,CAAC;IAC1B;EACF;EAEAJ,WAAWA,CAACG,KAAK,EAAE;IACjBxB,OAAO,CAACwB,KAAK,CAAC,kBAAkB,EAAEA,KAAK,CAAC;IACxC;EACF;EAEAD,aAAaA,CAACG,KAAK,EAAE;IACnB,IAAI;MACF,MAAMG,IAAI,GAAGC,IAAI,CAACC,KAAK,CAACL,KAAK,CAACG,IAAI,CAAC;MACnC,IAAI,IAAI,CAACnC,cAAc,EAAE;QACvB,IAAI,CAACA,cAAc,CAACmC,IAAI,CAAC;MAC3B;IACF,CAAC,CAAC,OAAOL,KAAK,EAAE;MACdxB,OAAO,CAACwB,KAAK,CAAC,kCAAkC,EAAEA,KAAK,CAAC;IAC1D;EACF;EAEAC,iBAAiBA,CAAA,EAAG;IAClB,IAAI,IAAI,CAAC7B,iBAAiB,GAAG,IAAI,CAACC,oBAAoB,EAAE;MACtD,IAAI,CAACD,iBAAiB,EAAE;MACxB,MAAMoC,KAAK,GAAGC,IAAI,CAACC,GAAG,CAAC,IAAI,GAAGD,IAAI,CAACE,GAAG,CAAC,CAAC,EAAE,IAAI,CAACvC,iBAAiB,GAAG,CAAC,CAAC,EAAE,KAAK,CAAC;MAE7EI,OAAO,CAACC,GAAG,CAAC,gCAAgC,IAAI,CAACL,iBAAiB,OAAOoC,KAAK,IAAI,CAAC;;MAEnF;MACA,IAAI,IAAI,CAAClC,gBAAgB,EAAE;QACzBsC,YAAY,CAAC,IAAI,CAACtC,gBAAgB,CAAC;MACrC;MAEA,IAAI,CAACA,gBAAgB,GAAGuC,UAAU,CAAC,MAAM;QACvCrC,OAAO,CAACC,GAAG,CAAC,4BAA4B,IAAI,CAACL,iBAAiB,IAAI,IAAI,CAACC,oBAAoB,GAAG,CAAC;QAC/F,IAAI,CAACE,OAAO,CAAC,CAAC;MAChB,CAAC,EAAEiC,KAAK,CAAC;IACX,CAAC,MAAM;MACLhC,OAAO,CAACwB,KAAK,CAAC,oCAAoC,CAAC;IACrD;EACF;EAEAc,WAAWA,CAACC,IAAI,EAAEC,OAAO,EAAE;IACzB,IAAI,CAAC,IAAI,CAAChD,MAAM,IAAI,CAAC,IAAI,CAACC,WAAW,EAAE;MACrCO,OAAO,CAACwB,KAAK,CAAC,8CAA8C,CAAC;MAC7D,OAAO,KAAK;IACd;IAEA,IAAI;MACF,MAAMiB,OAAO,GAAGX,IAAI,CAACY,SAAS,CAAC;QAAEH,IAAI;QAAEC;MAAQ,CAAC,CAAC;MACjD,IAAI,CAAChD,MAAM,CAACmD,IAAI,CAACF,OAAO,CAAC;MACzB,OAAO,IAAI;IACb,CAAC,CAAC,OAAOjB,KAAK,EAAE;MACdxB,OAAO,CAACwB,KAAK,CAAC,kCAAkC,EAAEA,KAAK,CAAC;MACxD,OAAO,KAAK;IACd;EACF;EAEAoB,QAAQA,CAACC,IAAI,EAAE;IACb,OAAO,IAAI,CAACP,WAAW,CAAC,MAAM,EAAEO,IAAI,CAAC;EACvC;EAEAC,SAASA,CAACC,SAAS,EAAE;IACnB,OAAO,IAAI,CAACT,WAAW,CAAC,OAAO,EAAES,SAAS,CAAC;EAC7C;EAEAC,QAAQA,CAACC,IAAI,EAAE;IACb,OAAO,IAAI,CAACX,WAAW,CAAC,MAAM,EAAEW,IAAI,CAAC;EACvC;EAEAC,iBAAiBA,CAACC,OAAO,EAAE;IACzB,IAAI,CAACzD,cAAc,GAAGyD,OAAO;EAC/B;EAEAC,sBAAsBA,CAACD,OAAO,EAAE;IAC9B,IAAI,CAACxD,mBAAmB,GAAGwD,OAAO;EACpC;EAEAE,UAAUA,CAAA,EAAG;IACX,IAAI,IAAI,CAACvD,gBAAgB,EAAE;MACzBsC,YAAY,CAAC,IAAI,CAACtC,gBAAgB,CAAC;MACnC,IAAI,CAACA,gBAAgB,GAAG,IAAI;IAC9B;IAEA,IAAI,IAAI,CAACN,MAAM,EAAE;MACf,IAAI,CAACA,MAAM,CAACU,KAAK,CAAC,IAAI,EAAE,qBAAqB,CAAC;MAC9C,IAAI,CAACV,MAAM,GAAG,IAAI;IACpB;IAEA,IAAI,CAACC,WAAW,GAAG,KAAK;EAC1B;AACF;;AAEA;AACA,MAAM6D,gBAAgB,GAAG,IAAIhE,gBAAgB,CAAC,CAAC;AAC/C,eAAegE,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}